
    Term work on Design &      
   Analysis of Algorithms LAB                                   (PCS 409) 2022-23    
 

1  	Program to Implement Linear Search Method and also find Total No of Comparisons.  	  
2  	Program to Implement Binary Search Method and also find Total No of Comparisons  	  
3  	Implement a program to find whether a given key element is present in the sorted array or not.(Jump Search)  	  
4  	Implement a program to find whether the given key element is present in the array or not. If present, then also find the number of copies of given key  	  
5  	Given a sorted array of positive integers, design an algorithm and implement it using a program to find three  indices i, j, k such that arr[i] + arr[j] = arr[k]  	  
6  	Given an array of nonnegative integers, design an algorithm and a program to count the number of pairs of integers such that their difference is equal to a given key, K.  	  
7  	Program to implement insertion sort and also find number of comparisons and shifts.  	  
8  	Program to implement selection sort and also find number of comparisons and swaps.  	  
9  	Given an unsorted array of positive integers, design an algorithm and implement it using a program to find whether there are any duplicate elements in the array or not  	  
10  	Program to implement merge sort and also find number of comparisons and inversions  	  
11  	Program to implement quick sort and also find number of comparisons and swaps.  	  
12  	Given an unsorted array of integers, design an algorithm and implement it using a program to find Kth smallest or largest element in the array.  	  
13  	Given an unsorted array of alphabets containing duplicate elements. Design an algorithm and implement it using a program to find which alphabet has the maximum number of occurrences and print it.  	  
14  	Given an unsorted array of integers, design an algorithm and implement it using a program to find whether two elements exist such that their sum is equal to the given key element  	  
15  	You have been given two sorted integer arrays of size m and n. Design an algorithm and implement it using a program to find a list of elements which are common to both.  	  
 
16  	Given a (directed/undirected) graph, design an algorithm and implement it using a program to find if a path exists between two given vertices or not. (Hint: use DFS)  	   
17  	Given a graph, design an algorithm and implement it using a program to find if a graph is bipartite or not. (Hint: use BFS)  	   
18  	Given a directed graph, design an algorithm and implement it using a program to find whether cycle exists in the graph or not.  	   
19  	After end term examination, Akshay wants to party with his friends. All his friends are living as paying guest and it has been decided to first gather at Akshay’s house and then move  towards party location. The problem is that no one knows the exact address of his house in the city. Akshay as a computer science wizard knows how to apply his theory subjects in his real life and came up with an amazing idea to help his friends. He draws a graph by looking in to location of his house and his friends’ location (as a node in the graph) on a map. He wishes to find out shortest distance and path covering that distance from each of his friend’s location to his house and then whatsapp them this path so that they can reach his house in minimum time. Akshay has developed the program that implements Dijkstra’s algorithm but not sure about correctness of results. Can you also implement the same algorithm and verify the correctness of Akshay’s results?  	   
20  	Design an algorithm and implement it using a program to solve previous question's problem using Bellman- Ford's shortest path algorithm.  	   
21  	Given a directed graph with two vertices ( source and  destination). Design an algorithm and implement it using a program to find the weight of the shortest path from source to destination with exactly k edges on the path.  	   
22  	Assume that a project of road construction to connect some cities is given to your friend. Map of these cities and roads which will connect them (after construction) is provided to him in the form of a graph. Certain amount of rupees is associated with construction of each road. Your friend has to calculate the minimum budget required for this project. The budget should be designed in such a way that the cost of connecting the cities should be minimum and number of roads required to connect all the cities should be minimum (if there are N cities then only N-1 roads need to be constructed). He asks you for help. Now, you have to help your friend by designing an algorithm which will find minimum cost required to connect these cities. (use Prim's algorithm)  	   
23  	Implement the previous problem using Kruskal's algorithm.  	   
24  	Assume that same road construction project is given to another person. The amount he will earn from this project is directly proportional to the budget of the project. This person is greedy, so he decided to maximize the budget by constructing those roads who have highest construction cost. Design an algorithm and implement it using a program to find the maximum budget required for the project.  	   
25  	Given a graph, Design an algorithm and implement it using a program to implement Floyd- Warshall all pair shortest path algorithm.  	   
26  	Given a knapsack of maximum capacity w. N items are provided, each having its own value and weight. You have to Design an algorithm and implement it using a program to find the list of the selected items such that the final selected content has weight w and has maximum value. You can take fractions of items,i.e. the items can be broken into smaller pieces so that you have to carry only a fraction xi of item i, where 0 ≤xi≤ 1.  	   
27  	Given an array of elements. Assume arr[i] represents the size of file i. Write an algorithm and a program to merge all these files into single file with minimum computation. For given two files  
A and B with sizes m and n, computation cost of merging them is O(m+n). (Hint: use greedy approach)  	   
28  	Given a list of activities with their starting time and finishing time. Your goal is to select maximum number of activities that can be performed by a single person such that selected activities must be non-conflicting. Any activity is said to be non-conflicting if starting time of an activity is greater than or equal to the finishing time of the other activity. Assume that a person can only work on a single activity at a time.  	   
29  	Given a long list of tasks. Each task takes specific time to accomplish it and each task has a deadline associated with it. You have to design an algorithm and implement it using a program to find maximum number of tasks that can be completed without crossing their deadlines and also find list of selected tasks.  	   
30  	Given an unsorted array of elements, design an algorithm and implement it using a program to find whether majority element exists or not. Also find median of the array. A majority element is an element that appears more than n/2 times, where n is the size of array.  	   
 
31  	Given a sequence of matrices, write an algorithm to find most efficient way to multiply these matrices together. To find the optimal solution, you need to find the order in which these matrices should be multiplied.  	   
32  	Given a set of available types of coins. Let suppose you have infinite supply of each type of coin. For a given value N, you have to Design an algorithm and implement it using a program to find number of ways in which these coins can be added to make sum value equals to N.  	   
33  	Given a set of elements, you have to partition the set into two subsets such that the sum of elements in both subsets is same. Design an algorithm and implement it using a program to solve this problem.  	   
34  	Given two sequences, Design an algorithm and implement it using a program to find the length of longest subsequence present in both of them. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.  	   
35  	Given a knapsack of maximum capacity w. N items are provided, each having its own value and weight. Design an algorithm and implement it using a program to find the list of the selected items such that the final selected content has weight <= w and has maximum value. Here, you cannot break an item i.e. either pick the complete item or don't pick it. (0-1 property).  	   
36  	Given a string of characters, design an algorithm and implement it using a program to print all possible permutations of the string in lexicographic order.  	   
37  	Given an array of characters, you have to find distinct characters from this array. Design an algorithm and implement it using a program to solve this problem using hashing. (Time Complexity = O(n))  	   
38  	Given an array of integers of size n, design an algorithm and write a program to check whether this array contains duplicate within a small window of size k < n.  	   
39  	Given an array of nonnegative integers, Design an algorithm and implement it using a program to find two pairs (a,b) and (c,d) such that a*b = c*d, where a, b, c and d are distinct elements of array.  	   
 

  
 
  
  
40  	Given a number n, write an algorithm and a program to find nth ugly number. Ugly numbers are those numbers whose only prime factors are 2, 3 or 5. The sequence 1, 2, 3, 4, 5, 6, 8, 9,  10, 12, 15, 16, 18, 20, 24,. is sequence of ugly numbers.  	   
41  	Given a directed graph, write an algorithm and a program to find mother vertex in a graph. A mother vertex is a vertex v such that there exists a path from v to all other vertices of the graph.  	   
 
  
 

















   
  

 
WEEK - 1  
Q1. Given an array of non-negative integers, design a linear algorithm and implement it using a program to find whether given key element is present in the array or not. Also, find total number of comparisons for each input case.  
(Time Complexity = O(n), where n is the size of input)  
   
SOURCE CODE

#include <iostream> using namespace std;  
int main()  
{
    int t;
    cout << "Enter the number of test cases: ";
    cin >> t;
    while (t != 0)
    {
        int n, key = -1, i;
        cout << "Enter the size of array: ";
        cin >> n;
        int arr[n];
        cout << "Enter the elements: ";
        for (int i = 0; i < n; i++)
            cin >> arr[i];
        cout << "Enter the key: ";
        cin >> key;
        for (i = 0; i < n; i++)
        {
            if (key == arr[i])
            {
                cout << "Element found!" << endl;
                break;
            }
        }
        if (i == n)
        {
            cout << "Element not found!" << endl;
            cout << "Total number of comparison: " << i << endl;
        }
        else
        {
            cout < < "Tot al numbe r of compa rison
                : "<<i+
                  1
                  << en dl;
        }
        t--;
    }
    return 0;  
}  
  
  
  
  
  
 
Q2. Given an already sorted array of positive integers, design an algorithm and implement it using program to find whether given key element is present in the array or not. Also, find the total number of comparisons for each input case.  
(Time Complexity = O(logn), where n is the size of input)  
   
SOURCE CODE
#include <iostream> using namespace std;  
 int binary_search(int arr[], int l, int r, int 
key)  
{
    if (r < l)
        return -1;
    int mid = l + (r - l) / 2;
    if (arr[mid] == key)
        return mid;
    if (arr[mid] > key)
        return binary_search(arr, l, mid - 1, key);

    return binary_search(arr, mid + 1, r,
                         key); }  
  
int countFrequency(int arr[], int n, int key)  
{
    int pos = binary_search(arr, 0, n - 1, key);
    if (pos == -1)
        return -1;
    int count = 1;
    int left = pos - 1, right = pos + 1;
    while (left >= 0 && arr[left] == key)
    {
        count++;
        left--;
    }
    while (right < n && arr[right] == key)
    {
        count++;
        right +
            +;
    }
    return count;  
}  int main()  
{
    int n, key;
    int t;
    cout << "\nEnter no. of times: ";
    cin >> t;
    while (t != 0)
    {
        cout << "\nEnter the size of array: ";
        cin >> n;
        int a[n];
        cout << "\nEnter the elements of array: ";
        for (int i = 0; i < n; i++)
            cin >> a[i];
        cout << "\nEnter the key element: ";
        cin >> key;
        cout << key << " " << countFrequency(a, n, key);
        t--;
    }
    return 0;  
}  
  
 OUTPUT  
  
  
Q3. Given an already sorted array of positive integers, design an algorithm and implement it using a program to find whether a given key element is present in the sorted array or not . For an array arr[n], search at the indexes arr[0], arr[2], arr[4],….,arr[2k] and so on. Once the interval (arr[2k] < key < arr[2k+1]) is found, perform a linear search operation from the index 2k to find the element key.  
(Complexity < O(n), n = no. of elements to be scanned for searching.)  
   
SOURCE CODE
#include <iostream> using namespace std;  
void js(int arr[],int n,int key)  
{
    int i = 0;
    int j = 2;
    int comp = 0;
    while (arr[j] <= key && j < n)
    {
        comp++;
        i = j;
        j = j + 2;
        if (j > n -
                    1)
        {
            j = n;
        }
    }
    for (int k = i; k < j; k++)
    {
        int count = 0;
        count++;
        if (arr[k] == ke y)
        {
            cout << "Key is present !\n"
                 << (comp + count) << endl;
        }
        else
        {
            cout << "Key is not present !\n"
                 << (comp + count) << endl;
            break;
        }
    }  
}  int main()  
{
    int t, n, arr[100], key;
    cout << "Enter test cases: 
            "; cin>>t; while(t--)  
    {
        cout << "\nEnter the no. of element in the array: ";
        cin >> n;
        cout << "\nEnter the elements in the array: ";
        for (int i = 0; i < n; i++)
        {
            cin >> arr[i];
        }
        cout << "Enter the value which you want to search: 
                "; cin>>key; js(arr,n,key);  
    }
    return 0;  
}  


WEEK - 2  
Q1. Given a sorted array of positive integers containing few duplicate elements, design an algorithm and implement it using a program to find whether the given key element is present in the array or not. If present, then also find the number of copies of given key.  
(Time Complexity = O(log n))  
  
SOURCE CODE
#include <bits/stdc++.h> using namespace std;  
 int 
main()  
{
    int t, flag = 0;
    cin >> t;
    while (t != 0)
    {
        int n;
        cout << "Enter the size of array: ";
        cin >> n;
        int arr[n], key;
        cout << "Enter the elements: ";
        for (int i = 0; i < n; i++)
            cin >> arr[i];
        sort(arr, arr + n);
        for (int i = 1; i < n; i++)
            if (arr[i] == arr[i - 1])
            {
                flag = 1;
                break;
            }
        if (flag == 0)
            cout << "NO\n";
        else
            cout << "YES\n";
        t--;
    }  
}  
   
  
Q2. Given a sorted array of positive integers, design an algorithm and implement it using a program to find three indices i, j, k such that arr[i] + arr[j] = arr[k].  
  
SOURCE CODE
#include <iostream> using namespace std;  
 int 
main()  
{
    int t;
    cin >> t;
    while (t !=
           0)
    {
        int n, key, flag = 0;
        cout << "Enter the size of array: ";
        cin >> n;
        int a[n];
        cout << "Enter the elements of array: ";
        for (int i = 0; i < n; i++)
            cin >> a[i];
        for (int i = 0; i < n - 2; i++)
        {
            for (int j = i + 1; j < n - 1; j++)
            {
                for (int k = j + 1; k < n; k++)
                {
                    if (a[i] + a[j] == a[k])
                    {
                        flag++;
                        cout << i + 1 << " " << j + 1 << " " << k + 1 << "\n";
                    }
                }
            }
        }
        if (flag == 0)
            cout << "No 
                        sequence found."; t--; } return 0;  }  
                        OUTPUT

Q3.Given an array of non - negative integers, design an algorithm and a program to count the number of pairs of integers such that their difference is equal to a given key, K.SOURCE CODE
#include <iostream> 
using namespace std;
                                                                                                                                               int main()
            {
                int t;
                cin >> t;
                while (t != 0)
                {
                    int
                        n,
                        key;
                    cout << "Enter the size of array: ";
                    cin >> n;
                    int arr[n];
                    cout << "Enter the size of array: ";
                    for (int i = 0; i < n; i++)
                        cin >> arr[i];
                    cout << "Enter the key: ";
                    cin >> key;
                    for (int i = 0; i < n - 1; i++)
                        for (int j = i + 1; j < n; j++)
                            if (abs(arr[i] - arr[j]) == key)
                                cout << "indexes are " << i << j << " ";
                    t--;
                }
                return 0;
            }
        OUTPUT

WEEK – 3  
Q1. Given an unsorted array of integers, design an algorithm and a program to sort the array using insertion sort. Your program should be able to find number of comparisons and shifts (shifts – total no. of times the array elements are shifted from their place) required for sorting the array.  
  
  
SOURCE CODE
#include <iostream> using namespace std;  
 int 
main()
{
    int t, n;
    cout << "Test cases: ";
    cin >> t;
    while (t != 0)
    {
        cout << "Size of array: ";
        cin >> n;
        int arr[n], temp, j, shift = 0, comp = 0;
        cout << "Elements: ";
        for (int i = 0; i < n; i++)
            cin >> arr[i];
        for (int i = 1; i < n; i++)
        {
            j = i - 1;
            temp = arr[i];
            while (j >= 0 && arr[j] > temp)
            {
                arr[j + 1] = arr[j];
                j--;
                shift++;
                comp++;
            }
            arr[j + 1] = temp;
            shift++;
        }
        for (int i = 0; i < n; i++)
            cout << arr[i] << " ";
        cout << "\ncomparisons = " << comp << endl;
        cout << "shifts = " << shift << endl;
        t--;
    }
    return 0;
}
OUTPUT

Q2.Given an unsorted array of integers, design an algorithm and implement a program to sort this array using selection sort.Your program should also find number of comparisons and number of swaps required.SOURCE CODE

#include <iostream> using namespace std;
                                        int
                                        main()
{
    int t, n;
    cout << "Test Cases: ";
    cin >> t;
    while (t != 0)
    {
        cout << "Size of array: ";
        cin >> n;
        int arr[n], temp, j, k, swaps = 0, comp = 0;
        cout << "Elements: ";
        for (int i = 0; i < n; i++)
            cin >> arr[i];
        for (int i = 0; i < n - 1; i++)
        {
            for (k = j = i; j < n - 1; j++)
            {
                if (arr[j] < arr[k])
                    k = j;
                comp++;
            }
            temp = arr[i];
            arr[i] = arr[k];
            arr[k] = temp;
            swaps++;
        }
        for (int i = 0; i < n; i++)
            cout << arr[i] << " ";
        cout << "\ncomparisons = 
                "<<comp<<endl; cout<<" shifts =
            "<<swaps<<endl; t--; } return 0;  
    }

    OUTPUT

    Q3.Given an unsorted array of positive integers, design an algorithm and implement it using a program to find whether there are any duplicate elements in the array or not .(use sorting)(Time Complexity = O(n log n))

                                                                                                                                                                                   SOURCE CODE
#include <iostream> using namespace std;
                                                                                                                                                                               int
                                                                                                                                                                               main()
    {
        int t, flag = 0;
        cout << "Test Cases: ";
        cin >> t;
        while (t != 0)
        {
            int n;
            cout << "\nEnter the size of array: ";
            cin >> n;
            int arr[n], key;
            cout << "Enter the elements: ";
            for (int i = 0; i < n; i++)
                cin >> arr[i];
            sort(arr, arr + n);
            for (int i = 1; i < n; i++)
                if (arr[i] == arr[i - 1])
                {
                    flag = 1;
                    break;
                }

            if (flag == 0)
                cout << "NO\n";
            else
                cout << "YES\n";
            cout << "Sorted Array: ";
            for (int i = 0; i < n; i++)
                cout << arr[i] << " ";
            t--;
        }
    }

    OUTPUT

    WEEK – 4 Q1.Given an unsorted array of integers, design an algorithm and implement it using a program to sort an array of elements by dividing the array into two subarrays and combining these subarrays after sorting each one of them.Your program should also find number of comparisons and inversions during sorting the array.

                                                     SOURCE CODE
#include <iostream> using namespace std; void swapping(int &a, int &b) { int temp; temp = a; a = b; b
                                                     = temp;
}
void display(int *array, int size)
{
    for (int i = 0; i < size; i++)
        cout << array[i] << " ";
    cout << endl;
}
void merge(int *array, int l, int m, int r)
{
    int i, j, k, nl, nr;
    nl = m - l + 1;
    nr = r - m;
    int larr[nl], rarr[nr];
    for (i = 0; i < nl; i++)
        larr[i] = array[l + i];
    for (j = 0; j < nr; j++)
        rarr[j] = array[m + 1 + j];
    i = 0;
    j = 0;
    k = l;
    while (i < nl && j < nr)
    {
        if (larr[i] <= rarr[j])
        {
            array[k] = larr[i];
            i++;
        }
        else
        {
            array[k] = rarr[j];
            j++;
        }
        k++;
    }
    while (i < nl)
    {
        array[k] = larr[i];
        i++;
        k++;
    }
    while (j < nr)
    {
        array[k] = rarr[j];
        j++;
        k++;
    }
}
void mergeSort(int *array, int l, int r)
{
    int m;
    if (l < r)
    {
        int m = l + (r - l) / 2;
        mergeSort(array, l, m);
        mergeSort(array, m + 1, r);
        merge(array, l, m, r);
    }
}
int main()
{
    int n;
    cout << "Enter the number of elements: 
            "; cin >> n; int arr[n];  cout << " Enter elements : " << endl; for(int i = 0; i<n; i++) {  cin >> arr[i];  
}
cout << "Array before Sorting: 
        "; display(arr, n); mergeSort(arr, 0, n-1 cout << " Array after Sorting : "; display(arr, n);  
    }
    OUTPUT

Q2. Given an unsorted array of integers, design an algorithm and implement it using a program to sort an array of elements by partitioning the array into two subarrays based on a pivot element such that one of the sub arrays holds values smaller than the pivot element while another subarray holds values greater than the pivot element. Pivot element should be selected randomly from the array. Your program should also find number of comparisons and swaps required for sorting the array.  
  
  
SOURCE CODE
#include <iostream> using namespace std;  
 void quickSort(int arr[], int l, int 
h)
{
if (l >= h)
    return;
int pivot = arr[l];
int i = l, j = h;
while (i < j)
{
    while (pivot >= arr[i] && i < j)
        i++;
    while (pivot < arr[j])
        j--;
    if (i < j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
arr[l] = arr[j];
arr[j] = pivot;
quickSort(arr, l, j1);
quickSort(arr, j + 1, h);
}

int main()
{
int t, n;
cout << "Test Cases: ";
cin >> t;
while (t != 0)
{
    cout << "Size of Array: ";
    cin >> n;
    int arr[n], temp, j, k, swaps = 0, comp = 0;
    for (int i = 0; i < n; i++)
        cin >> arr[i];
    quickSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    t--;
}
return 0;
}

OUTPUT

Q3.Given an unsorted array of integers, design an algorithm and implement it using a program to find Kth smallest or largest element in the array.(Worst case Time Complexity = O(n))

                                                                                                                         SOURCE CODE
#include <iostream> using namespace std;
                                                                                                                     int
                                                                                                                     partition(int arr[], int l, int r)
{
int x = arr[r], i = l;
for (int j = l; j <= r - 1; j++)
{
    if (arr[j] <= x)
    {
        swap(arr[i], arr[j]);
        i++;
    }
}
swap(arr[i], arr[r]);
return i;
}

int kthSmallest(int arr[], int l, int r, int k)
{
if (k > 0 && k <= r - l + 1)
{
    int index = partition(arr, l, r);
    if (index - l == k - 1)
        return arr[index];
    if (index - l > k - 1)
        return kthSmallest(arr, l, index - 1, k);
    return kthSmallest(arr, index + 1, r, k - index + l - 1);
}
return INT_MAX;
}

int main()
{
int t, n;
cout << "Test Cases: ";
cin >> t;
while (t != 0)
{
    cout << "\nSize of Array: ";
    cin >> n;
    int arr[n], k;
    cout << "Elements: ";
    for (int i = 0; i < n; i++)
        cin >> arr[i];
    cin >> k;
    cout << kthSmallest(arr, 0, n - 1, k);
    t--;
}
}

OUTPUT

WEEK – 5 Q1.Given an unsorted array of alphabets containing duplicate elements.Design an algorithm and implement it using a program to find which alphabet has maximum number of occurrences and print it.(Time Complexity = O(n))

    SOURCE CODE
#include <iostream> using namespace std;
    int
    main()
{
int t;
cout << "Test Cases: ";
cin >> t;
while (t != 0)
{
    int n;
    cout << "Size of Array: ";
    cin >> n;
    char arr[n], key, max = 'a';
    cout << "Elements: ";
    for (int i = 0; i < n; i++)
        cin >> arr[i];
    for (int i = 0; i < n; i++)
        if (arr[i] 97 > max - 97)
            max = arr[i];
    int auxArr[(max - 97) + 1] =
        {0};
    for (int i = 0; i < n; i++)
        auxArr[arr[i] - 97]++;
    max = max - 97;
    int max2 = INT_MIN, index;
    for (int i = 0; i < max + 1; i++)
        if (auxArr[i] > max2)
        {
            max2 = auxArr[i];
            index = i;
        }
    if (max2 == 1)
        cout << "No-
            Duplicate Present\n "; else {    	char c = char(index+97);  
            cout
             << c << " " << max2 << "\n";
}
t -
    -;
}
return 0;  
}  
  
  
  
  
 OUTPUT  
  
  
   
  
Q2. Given an unsorted array of integers, design an algorithm and implement it using a program to find whether two elements exist such that their sum is equal to the given key element.  
(Time Complexity = O(n log n))  
   
SOURCE CODE
#include <iostream> using namespace std; int main()  
{
    int t, n;
    cout << "Test Cases: ";
    cin >> t;
    while (t != 0)
    {
        cout << "Size of Array: ";
        cin >> n;
        int arr[n], key, flag = 0;
        cout << "Elements: ";
        for (int i = 0; i < n; i++)
            cin >> arr[i];
        cin >> key;
        sort(arr, arr +
                      n);
        int l = 0, r = n - 1;
        while (l <= r)
        {
            if (arr[l] + arr[r] == key)
            {
                cout << arr[l] << " " << arr[r] << endl;
                flag = 1;
                break;
            }
            else if (arr[l] + arr[r] > key)
                r--;
            else if (arr[l] + arr[r] < key)
                l++;
        }
        if (flag == 0)
            cout << "No such elements Exist\n";
        t--;
    }
    return 0;  
}  
  
  
  
  
  
  
  
OUTPUT  
  
  
Q3: You have been given two sorted integer arrays of size m and n. Design an algorithm and implement it using a program to find list of elements which are common to both. (Time Complexity = O(m+n)).

#include <stdio.h> #define max 100 int ifexists(int z[], int u, int v)  
{
    int i;
    if (u == 0)
        return 0;
    for (i = 0; i <= u; i++)
        if (z[i] == v)
            return (1);
    return (0);  } void main()  
{
    int p[max], q[max], r[max];
    int m, n;
    int i, j, k;
    k = 0;
    printf("Enter the length of the first array:");
    scanf("%d", &m);
    printf("Enter %d elements of the first array\n", m);
    for (i = 0; i < m; i++)
        scanf("%d", &p[i]);
    printf("\nEnter the length of the second array:");
    scanf("%d", &n);
    printf("Enter %d elements of the second array\n", n);
    for (i = 0; i < n; i++)
        scanf("%d", &q[i]);
    k = 0;
    for (i = 0; i < m; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (p[i] == q[j])
            {
                if (!ifexists(r, k, p[i]))
                {
                    r[k] = p[i];
                    k++;
                }
            }
        }
    }
    if (k > 0)
    {
        printf("\nThe common elements in the two arrays are:\n");
        for (i = 0; i < k; i++)
            printf("%d\n", r[i]);
    }
    else printf("There are no common elements in the two arr 
 
 
                                                             WEEK 6 
Q1: Given a (directed/undirected) graph, design an algorithm and implement it using a program to find if a path exists between two given vertices or not. (Hint: use DFS).
#include <iostream> #include <list> using namespace std; class Graph {     int V;      list<int> *adj;  public:     Graph(int V); 
    void addEdge(int v, int w);      bool isReachable(int s, int d); 
}; 
 
Graph::Graph(int V) 
{
    this->V = V;
    adj = new list<int>[V]; 
}  
void Graph::addEdge(int v, int w) 
{
    adj[v].push_back(w);  
} 
bool Graph::isReachable(int s, int d) 
{
    if (s == d)
        return true;
    bool *visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
    list<int> queue;
    visited[s] = true;
    queue.push_back(s);
    list<int>::iterator i;

    while (!queue.empty())
    {
        s = queue.front();
        queue.pop_front();
        for (i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if (*i == d)
                return true;
            if (!visited[*i])
            {
                visited[*i] = true;
                queue.push_back(*i);
            }
        }
    }
    return false; 
} int main() 
{
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    int u = 1, v = 3;
    if (g.isReachable(u, v))
        cout << "\n There is a path from " << u << " to " << v;
    else
        cout << "\n There is no path from " << u << " to " << v;

    u = 3, v = 1;
    if (g.isReachable(u, v))
        cout << "\n There is a path from " << u << " to " << v;
    else
        cout << "\n There is no path from " << u << " to " << v;

    return 0; } 
 
  
 
OUTPUT 
 
   
 	 
Q2: Given a graph, design an algorithm and implement it using a program to find if a graph is bipartite or not. (Hint: use BFS) .
#include <iostream>
#include <queue> #define V 5 using namespace std; 
bool isBipartite(int G[][V], int src) 
{
    int colorArr[V];
    for (int i = 0; i < V; ++i)
        colorArr[i] = -1;
    colorArr[src] = 1;
    queue<int> q;
    q.push(src);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        if (G[u][u] == 1)
            return false;
        for (int v = 0; v < V; ++v)
        {
            if (G[u][v] && colorArr[v] == -1)
            {
                colorArr[v] = 1 - colorArr[u];
                q.push(v);
            }
            else if (G[u][v] && colorArr[v] == colorArr[u])
                return false;
        }
    }
    return true; 
} int main() {
    int G[][V] = {{0, 1, 1, 0, 0},
                  {1, 0, 1, 1, 1},
                  {1, 1, 0, 1, 0},
                  {0, 1, 1, 0, 1},
                  {0, 1, 0, 1, 0}};
    isBipartite(G, 0) ? cout << "Yes" : cout << "No";
    return 0; 
} 
OUTPUT 
  
Q3: Given a directed graph, design an algorithm and implement it using a program to find whether cycle exists in the graph or not.
#include <iostream> #include<bits/stdc++.h> using namespace std;  
bool iscycle(vector<int>adj[],int node,vector<int>&visited,vector<int>&dfsvisited) 
    {
    stack<pair<int, int>> st;
    visited[node] = 1;
    dfsvisited[node] = 1;
    for (auto i : adj[node])
    {
        if (visited[i] == 0)
        {
            if (iscycle(adj, i, visited, dfsvisited))
                return true;
        }
        else if (dfsvisited[i] == 1)
            return true;
    }
    dfsvisited[node] = 0;
    return false; 
    }      
bool isCyclic(int V, vector<int> adj[]) {
    vector<int> visited(V, 0);
    vector<int> dfsvisited(V, 0);
    for (int i = 0; i < V; i++)
    {
        if (visited[i] == 0)
        {
            if (iscycle(adj, i, visited, dfsvisited))
                return true;
        }
    }
    return false; 
    } int main() {
    int n, e, u, v;
    cin >> n >> e;
    vector<int> adj[n];
    for (int i = 0; i < e; i++)
    {
        cin >> u >> v;
        adj[u].push_back(v);
    }
    if (isCyclic(n, adj))
        cout << "Yes Cycle Exists";
    else
    {
        cout << "No Cycle Exists";
    }
    return 0; 
} 
 
OUTPUT 
 
   
   
 
WEEK 7 
Q1: Akshay has developed the program that implements Dijkstra’s algorithm but not sure about correctness of results. Can you also implement the same algorithm and verify the correctness of Akshay’s results? (Hint: Print shortest path and distance from friends’ location to Akshay’s house).
#include <iostream> #include<bits/stdc++.h> using namespace std; 
int minDistance(int dist[], bool processed[],int V) 
{
    int min = INT_MAX, min_index;
    for (int i = 0; i < V; i++)
        if (processed[i] == false && dist[i] <= min)
            min = dist[i], min_index = i;
    return min_index; 
} 
void printPath(int parent[], int j) 
{
    if (parent[j] == -1)
        return;
    printPath(parent, parent[j]);
    cout << j << " "; 
} 
void printSolution(int dist[], int V, int parent[],int src) 
{
    for (int i = 0; i < V; i++)
    {

        cout << src << " ";
        printPath(parent, i);
        cout << ":" << dist[i] << endl;
    } } 
void dijkstra(vector<vector<int>>graph, int src) 
{
    int V = graph.size();
    int dist[V];
    bool processed[V] = {false};
    int parent[V] = {-1};
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX;
    dist[src] = 0;

    for (int count = 0; count < V - 1; count++)
    {
        int u = minDistance(dist, processed, V);
        processed[u] = true;
        for (int v = 0; v < V; v++)
            if (!processed[v] && graph[u][v] && dist[u] + graph[u][v] < dist[v])
            {
                parent[v] = u;
                dist[v] = dist[u] + graph[u][v];
            }
    }
    printSolution(dist, V, parent, src); 
} int main() {
    int n, source, wt;
    cin >> n;
    vector<vector<int>> graph(n, vector<int>(n));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> wt;
            graph[i][j] = wt;
        }
    }
    cin >> source;
    dijkstra(graph, source);
    return 0; 
} 
 
OUTPUT 
  
   
 
 
 	 
 
Q2: Design an algorithm and implement it using a program to solve previous question's problem using Bellman- Ford's shortest path algorithm.
#include <iostream> #include <bits/stdc++.h> 
using namespace std; 
int minDistance(int dist[], bool processed[], int V) 
{
    int min = INT_MAX, min_index;
    for (int i = 0; i < V; i++)
        if (processed[i] == false && dist[i] <= min)
            min = dist[i], min_index = i;
    return min_index; 
} 
void printPath(int parent[], int j) 
{
    if (parent[j] == -1)
        return;
    printPath(parent, parent[j]);
    cout << j << " "; 
} 
void printSolution(int dist[], int V, int parent[], int src) 
{
    for (int i = 0; i < V; i++)
    {
        cout << src << " ";
        printPath(parent, i);
        cout << ":" << dist[i] << endl;
    } } 
void dijkstra(vector<vector<int>> graph, int src, int *dist, int *parent) 
{
    int V = graph.size();
    bool processed[V] = {false};

    for (int count = 0; count < V - 1; count++)
    {
        int u = minDistance(dist, processed, V);
        processed[u] = true;
        for (int v = 0; v < V; v++)
            if (!processed[v] && graph[u][v] && dist[u] + graph[u][v] < dist[v])
            {
                parent[v] = u;
                dist[v] = dist[u] + graph[u][v];
            }
    } } int main() {
    int n, source, wt;
    cin >> n;
    vector<vector<int>> graph(n, vector<int>(n));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> wt;
            graph[i][j] = wt;
        }
    }
    cin >> source;
    int dist[n];
    int parent[n] = {-1};
    for (int i = 0; i < n; i++)
        dist[i] = INT_MAX;
    dist[source] = 0;
    for (int i = 0; i < n; i++)
        dijkstra(graph, source, dist, parent);
    printSolution(dist, n, parent, source);
    return 0; } 
 
OUTPUT 
 
  
   
 
 
 
  
Q3: Given a directed graph with two vertices ( source and destination). Design an algorithm and implement it using a program to find the weight of the shortest path from source to destination with exactly k edges on the path.
#include <iostream> #include<bits/stdc++.h> using namespace std; 
 
int shortestPath(vector<vector<int>>graph, int u, int v, int k,int V) 
{
    if (k == 0 && u == v)
        return 0;
    if (k == 1 && graph[u][v] != 0)
        return graph[u][v];
    if (k <= 0)
        return -1;

    int res = INT_MAX;

    for (int i = 0; i < V; i++)
    {
        if (graph[u][i] != 0 && u != i && v != i)
        {
            int rec_res = shortestPath(graph, i, v, k - 1, V);
            if (rec_res != INT_MAX)
                res = min(res, graph[u][i] + rec_res);
        }
    }
    return res; 
}   int main() {
    int V, n, src, dest, k;
    cin >> V;
    vector<vector<int>> graph(V, vector<int>(V));
    for (int i = 0; i < V; i++)
    {
        for (int j = 0; j < V; j++)
        {
            cin >> n;
            graph[i][j] = n;
        }
    }
    cin >> src >> dest >> k;

    int ans = shortestPath(graph, src, dest, k, V);
    if (ans == -1)
        cout << "no path of length k is available" << endl;
    else
        cout << "Weight of shortest Path(" << src << "," << dest << ") with " << k << " edges=" << ans;
    return 0; 
} 
 
 
OUTPUT 
  
  
 
WEEK 8 
Q1: Assume that a project of road construction to connect some cities is given to your friend………
#include <iostream> #include<bits/stdc++.h> 
using namespace std; int main() {
    int N, num;
    cin >> N;
    vector<vector<int>> graph(N, vector<int>(N));
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            cin >> num;
            graph[i][j] = num;
        }
    }
    int key[N];
    int parent[N];
    bool mstset[N];

    for (int i = 0; i < N; i++)
    {
        key[i] = INT_MAX;
        mstset[i] = false;
    }
    key[0] = 0;
    parent[0] = -1;
    for (int count = 0; count < N - 1; count++)
    {
        int mini = INT_MAX, u;
        for (int i = 0; i < N; i++)
        {
            if (mstset[i] == false && key[i] < mini)
            {
                mini = key[i];
                u = i;
            }
        }
        mstset[u] = true;
        for (int i = 0; i < N; i++)
        {
            if (graph[u][i] && mstset[i] == false && key[i] > graph[u][i])
            {
                parent[i] = u;
                key[i] = graph[u][i];
            }
        }
    }
    int res = 0;
    for (int i = 1; i < N; i++)
    {
        cout << graph[i][parent[i]] << " ";
        res += graph[i][parent[i]];
    }
    cout << "Minimum Spanning Weight: " << res << endl;

    // return 0; 
} 
 
OUTPUT 
  
  
Q2: Implement the previous problem using Kruskal's algorithm. 
#include <iostream> #include<bits/stdc++.h> using namespace std ; 
 
bool comp(pair <pair<int,int>,int> p1,pair <pair<int,int> ,int> p2) 
{
    return (p1.second < p2.second); 
} 
int find(int src,int parent[]) 
{
    int i = src;
    while (parent[i] != -1)
    {
        i = parent[i];
    }
    return i; 
} 
bool uni(int x,int y,int parent[]) 
{
    int r1 = find(x, parent);
    int r2 = find(y, parent);
    if (r1 == r2)
        return true;
    parent[r1] = r2;
    return false; 
} 
void Krushkals(vector < pair <pair < int , int> , int > > &G , int edge, int v) 
{
    int i, x, y;
    sort(G.begin(), G.end(), comp);
    vector<pair<int, int>> MST;
    int sum = 0;
    int p[v];
    for (i = 0; i < v; i++)
    {
        p[i] = -1;
    }
    for (i = 0; i < edge; i++)
    {
        x = G[i].first.first;
        y = G[i].first.second;
        bool cycle = uni(x, y, p);
        if (cycle != true)
        {
            MST.push_back(make_pair(x, y));
            sum += G[i].second;
        }
        else
            continue;
    }
    cout << "Minimum Spanning Tree is " << endl;
    for (i = 0; i != MST.size(); i++)
    {
        cout << MST[i].first << " - " << MST[i].second << endl;
    }
    cout << "Minimum Weight is : " << sum << endl; } 
int main() {
    int ver, edge, i, j, src, dest, wt;
    cin >> ver;
    cin >> edge;
    vector<pair<pair<int, int>, int>> G;
    pair<int, int> x;
    pair<pair<int, int>, int> y;
    for (i = 0; i < edge; i++)
    {
        cin >> src >> dest >> wt;
        x = make_pair(src, dest);
        y = make_pair(x, wt);
        G.push_back(y);
    }
    Krushkals(G, edge, ver);
    return 0; 
} 
 
OUTPUT 
  
 
 
Q3: Assume that same road construction project is given to another person. The amount he will earn from this project is directly proportional to the budget of the project. This person is greedy, so he decided to maximize the budget by constructing those roads who have highest construction cost. Design an algorithm and implement it using a program to find the maximum budget required for the project.
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int N,num;     cin>>N; 
    vector<vector<int>>graph(N,vector<int>(N));     for(int i=0;i<N;i++) 
    {
    for (int j = 0; j < N; j++)
    {
        cin >> num;
        graph[i][j] = num;
    }     }     int key[N];     int parent[N];     bool mstset[N]; 
     
    for(int i=0;i<N;i++) 
    {
    key[i] = INT_MIN;
    mstset[i] = false;  
    }     key[0]=0;     parent[0]=-1; 
    for(int count=0;count<N-1;count++) 
    {
    int mini = INT_MIN, u;
    for (int i = 0; i < N; i++)
    {
        if (mstset[i] == false && key[i] > mini)
        {
            mini = key[i];
            u = i;
        }
    }
    mstset[u] = true;
    for (int i = 0; i < N; i++)
    {
        if (graph[u][i] && mstset[i] == false && key[i] < graph[u][i])
        {
            parent[i] = u;
            key[i] = graph[u][i];
        }
    }     }     int res=0;     for(int i=1;i<N;i++) 
    {
    cout << graph[i][parent[i]] << " ";
    res += graph[i][parent[i]]; 
    } 
    cout<<"Maximum Spanning Weight: "<<res<<endl; 
 
    return 0;
    }

    OUTPUT

    WEEK 9 Q1 : Given a graph, Design an algorithm and implement it using a program to implement FloydWarshall all pair shortest path algorithm.
#include <iostream>
#include <bits/stdc++.h> using namespace std; #define INF INT_MAX
                               void
                               printSolution(int V, vector<vector<int>> dist)
    {
        for (int i = 0; i < V; i++)
        {
            for (int j = 0; j < V; j++)
            {
                if (dist[i][j] == INF)
                    cout << "INF"
                         << "     ";
                else
                    cout << dist[i][j] << "     ";
            }
            cout << endl;
        }
    }
    void floydWarshall(int V, vector<vector<int>> graph)
    {
        int i, j, k;
        vector<vector<int>> dist(V, vector<int>(V));
        for (i = 0; i < V; i++)
            for (j = 0; j < V; j++)
                dist[i][j] = graph[i][j];
        for (k = 0; k < V; k++)
        {
            for (i = 0; i < V; i++)
            {
                for (j = 0; j < V; j++)
                {
                    if (dist[i][j] > (dist[i][k] + dist[k][j]) && (dist[k][j] != INF && dist[i][k] != INF))
                        dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
        cout << "Shortest Distance Matrix:" << endl;
        printSolution(V, dist);
    }
    int main()
    {
        int V = 5;
        vector<vector<int>> graph{{0, 10, 5, 5, INF}, {INF, 0, 5, 5, 5}, {INF, INF, 0, INF, 10}, {INF, INF, INF, 0, 20}, {INF, INF, INF, 5, 0}};

        floydWarshall(V, graph);
        return 0;
    }

    OUTPUT

    Q2 : Given a knapsack of maximum capacity w.N items are provided, each having its own value and weight.You have to Design an algorithm and implement it using a program to find the list of the selected items such that the final selected content has weight w and has maximum value.You can take fractions of items, i.e.the items can be broken into smaller pieces so that you have to carry53 only a fraction xi of item i, where 0 ≤xi≤ 1.
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n,w,p;     cin>>n;     vector<int>weight;     vector<int>price;     for(int i=0;i<n;i++)
    {
        cin >> w;
        weight.push_back(w);
    }
    for (int i = 0; i < n; i++)
    {
        cin >> p;
        price.push_back(p);
    }
    cin >> w;
    vector<pair<double, int>> perw;
    for (int i = 0; i < n; i++)
    {
        perw.push_back({((double)price[i]) / weight[i], i});
    }
    sort(perw.begin(), perw.end());
    vector<int> ans(n, 0);
    double temp = w;
    int i = n - 1;
    double res = 0;
    while (temp > 0)
    {
        if ((weight[perw[i].second]) <= temp)
        {
            res += price[perw[i].second];
            temp -= weight[(perw[i].second)];
            ans[i] = weight[(perw[i].second)];
        }
        else
        {
            res += temp * perw[i].first;
            ans[i] = temp;
            temp -= temp;
        }
        i--;
    }
    cout << "Maximum value : " << res << endl;
    cout << "item-weight" << endl;
    for (int i = 0; i < n; i++)
    {
        cout << i + 1 << "-" << ans[i] << endl;
    }
    return 0;
    }

    OUTPUT

    Q3 : Given an array of elements.Assume arr[i] represents the size of file i.Write an algorithm and a program to merge all these files into single file with minimum computation.For given two files A and B with sizes m and n, computation cost of merging them is O(m + n).(Hint
                                                                                                                                                                                                                                                                                  : use greedy approach)
                                                                                                                                                                                                                                        .
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {
                                                                                                                                                                                                                                    int n,
        num, n1, n2;
    cin >> n;
    vector<int> file;
    for (int i = 0; i < n; i++)
    {
        cin >> num;
        file.push_back(num);
    }
    priority_queue<int, vector<int>, greater<int>> q;
    for (int i = 0; i < num; i++)
    {
        q.push(file[i]);
    }
    int res = num;
    while (q.size() > 1)
    {
        n1 = q.top();
        q.pop();
        n2 = q.top();
        q.pop();
        res += (n1 + n2);
        q.push(n1 + n2);
    }
    cout << res;
    return 0;
    }
    OUTPUT

    WEEK 10 Q1 : Given a list of activities with their starting time and finishing time.Your goal is to select maximum number of activities that can be performed by a single person such that selected activities must be non - conflicting.Any activity is said to be non - conflicting if starting time of an activity is greater than or equal to the finishing time of the other activity.Assume that a person can only work on a single activity at a time.
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n,s,f;     cin>>n;
                                                                                                                                                                                                                                                                                                                                             vector<int>
                                                                                                                                                                                                                                                                                                                                                 start,
        finish;
    for (int i = 0; i < n; i++)
    {
        cin >> s;
        start.push_back(s);
    }
    for (int i = 0; i < n; i++)
    {
        cin >> f;
        finish.push_back(f);
    }
    vector<pair<int, int>> v;
    for (int i = 0; i < n; i++)
    {
        v.push_back({finish[i], i});
    }
    sort(v.begin(), v.end());

    int count = 1, i = v[0].second;
    vector<int> ans;
    ans.push_back(i + 1);
    for (int j = 1; j < n; j++)
    {
        if (start[v[j].second] >= finish[i])
        {
            count++;
            ans.push_back(v[j].second + 1);
            i = v[j].second;
        }
    }
    cout << "No. of non-conflicting activities: " << count << endl;
    cout << "List of selected activities: ";
    for (int i = 0; i < ans.size(); i++)
    {
        cout << ans[i] << " ";
    }
    return 0;
    }
    OUTPUT

    Q2 :.Given a long list of tasks.Each task takes specific time to accomplish it and each task has a deadline associated with it.You have to design an algorithm and implement it using a program to find maximum number of tasks that can be completed without crossing their deadlines and also find list of selected tasks.
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n,num;     cin>>n;     vector<int>task;     vector<int>finish;     for(int i=0;i<n;i++)
    {
        cin >> num;
        task.push_back(num);
    }
    for (int i = 0; i < n; i++)
    {
        cin >> num;
        finish.push_back(num);
    }
    vector<pair<int, int>> v;
    for (int i = 0; i < n; i++)
    {
        v.push_back({finish[i], i});
    }
    sort(v.begin(), v.end());
    int i = 0;
    vector<int> res;
    res.push_back(v[i].second + 1);
    int temp = task[v[i].second];
    for (i = 1; i < n; i++)
    {
        if (finish[v[i].second] - temp >= task[v[i].second])
        {
            res.push_back(v[i].second + 1);
            temp += task[v[i].second];
        }
    }
    cout << "Max number of tasks =" << res.size() << endl;
    cout << "Selected task numbers :";
    sort(res.begin(), res.end());
    for (int i = 0; i < res.size(); i++)
    {
        cout << res[i] << " ";
    }
    return 0;
    }
    OUTPUT

    Q3 : Given an unsorted array of elements, design an algorithm and implement it using a program to find whether majority element exists or not .Also find median of the array.A majority element isan element that appears more than n / 2 times, where n is the size of array.
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n;     cin>>n;     int arr[n];     for(int i=0;i<n;i++)
    {
        cin >> arr[i];
    }
    sort(arr + 0, arr + n);
    if (((arr[0] == arr[n / 2]) || (arr[n / 2] == arr[n - 1])) && n % 2 != 0)
        cout << "Yes" << endl;
    else if (n % 2 == 0 && ((arr[0] == arr[n / 2]) || (arr[n / 2] == arr[n - 1] && arr[n / 2] == arr[n / 2 -
                                                                                                     1])))
        cout << "Yes" << endl;
    else
        cout << "No" << endl;
    if (n % 2 != 0)
        cout << arr[n / 2] << endl;
    else
    {
        cout << (arr[(n - 1) / 2] + arr[n / 2]) / 2.0 << endl;
    }
    return 0;
    }
    OUTPUT

    WEEK 11 Q1 : Given a sequence of matrices, write an algorithm to find most efficient way to multiply these matrices together.To find the optimal solution, you need to find the order in which these matrices should be multiplied.
#include <iostream> #include<bits/stdc++.h> using namespace std;
                                                                                                                                                               int
                                                                                                                                                               solve(vector<int> arr, int i, int j, vector<vector<int>> &dp)
    {
        if (i >= j)
            return 0;
        if (dp[i][j] != -1)
            return dp[i][j];
        int mn = INT_MAX;
        for (int k = i; k < j; k++)
        {
            int tempans = solve(arr, i, k, dp) + solve(arr, k + 1, j, dp) + arr[i - 1] * arr[k] * arr[j];
            if (tempans < mn)
                mn = tempans;
        }
        return dp[i][j] = mn;
    }
    int main()
    {
        int n, n1, n2;
        cin >> n;
        vector<int> arr;
        for (int i = 0; i < n; i++)
        {
            cin >> n1 >> n2;
            if (i == 0)
            {
                arr.push_back(n1);
                arr.push_back(n2);
            }
            else
                arr.push_back(n2);
        }
        n = arr.size();
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
        cout << solve(arr, 1, n - 1, dp);
    }
    OUTPUT

    Q2 : Given a set of available types of coins.Let suppose you have infinite supply of each type of coin.For a given value N, you have to Design an algorithm and implement it using a program to find number of ways in which these coins can be added to make sum value equals to N.

#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n,m;     cin>>m;     int coin[m];     for(int i=0;i<m;i++)
    {
        cin >> coin[i];
    }
    cin >> n;
    int t[m + 1][n + 1];
    for (int i = 0; i <= m; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            if (i == 0)
                t[i][j] = 0;
            if (j == 0)
                t[i][j] = 1;
        }
    }
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (coin[i - 1] <= j)
                t[i][j] = t[i][j - coin[i - 1]] + t[i - 1][j];
            else
                t[i][j] = t[i - 1][j];
        }
    }
    cout << t[m][n] << endl;
    }
    OUTPUT

    Q3 : Given a set of elements, you have to partition the set into two subsets such that the sum of elements in both subsets is same.Design an algorithm and implement it using a program to solvethis problem.
#include <iostream> #include<bits/stdc++.h> using namespace std;
                                  int
                                  subsetsum(int arr[], int n, int w)
    {
        int t[n + 1][w + 1];
        for (int i = 0; i < n + 1; i++)
        {
            for (int j = 0; j < w + 1; j++)
            {
                if (i == 0)
                {
                    t[i][j] = 0;
                }
                if (j == 0)
                {
                    t[i][j] = 1;
                }
            }
        }
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= w; j++)
            {
                if (arr[i - 1] <= j)
                {
                    t[i][j] = (t[i - 1][j - arr[i - 1]]) || t[i - 1][j];
                }
                else if (arr[i - 1] > j)
                {
                    t[i][j] = t[i - 1][j];
                }
            }
        }
        return t[n][w];
    }
    int equalPartition(int N, int arr[])
    {
        int sum = 0;
        for (int i = 0; i < N; i++)
        {
            sum += arr[i];
        }
        if (sum % 2 != 0)
        {
            return 0;
        }
        else if (sum % 2 == 0)
        {
            return subsetsum(arr, N, sum / 2);
        }
    }
    int main()
    {
        int n;
        cin >> n;
        int arr[n];
        for (int i = 0; i < n; i++)
        {
            cin >> arr[i];
        }
        if (equalPartition(n, arr))
            cout << "Yes" << endl;
        else
            cout << "No" << endl;
    }
    OUTPUT

    WEEK 12 Q1 : Given two sequences, Design an algorithm and implement it using a program to find the length of longest subsequence present in both of them.A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {
                                                                                                                                                                                                                                  string str1,
                 str2;
    cout << "Sequence1: ";
    cin >> str1;
    cout << "Sequence2: ";
    cin >> str2;
    int n = str1.size(), m = str2.size();
    int t[n + 1][m + 1];
    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            if (i == 0 || j == 0)
            {
                t[i][j] = 0;
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (str1[i - 1] == str2[j - 1])
            {
                t[i][j] = 1 + t[i - 1][j - 1];
            }
            else
            {
                t[i][j] = max(t[i][j - 1], t[i - 1][j]);
            }
        }
    }
    string str = "";
    int i = n, j = m;
    while (i > 0 && j > 0)
    {
        if (str1[i - 1] == str2[j - 1])
        {
            str += str1[i - 1];
            i--;
            j--;
        }
        else
        {
            if (t[i][j - 1] > t[i - 1][j])
                j--;
            else
                i--;
        }
    }
    reverse(str.begin(), str.end());
    cout << "Longest Common Subsequence: " << str << endl;
    cout << "Length = " << t[n][m] << endl;
    }

    OUTPUT

    Q2 : Given a knapsack of maximum capacity w.N items are provided, each having its own value and weight.Design an algorithm and implement it using a program to find the list of the selected items such that the final selected content has weight <= w and has maximum value.Here, you cannot break an item i.e.either pick the complete item or don't pick it. (0-1 property). 
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n,w,p;     cin>>n;     vector<int>wgt;     vector<int>price;     for(int i=0;i<n;i++)
    {
        cin >> w;
        wgt.push_back(w);
    }
    for (int i = 0; i < n; i++)
    {
        cin >> p;
        price.push_back(p);
    }
    cin >> w;
    int dp[n + 1][w + 1];
    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= w; j++)
        {
            if (i == 0 || j == 0)
                dp[i][j] = 0;
        }
    }
    vector<int> v1, v2;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= w; j++)
        {
            if (wgt[i - 1] <= j)
            {
                dp[i][j] = max(price[i - 1] + dp[i - 1][j - wgt[i - 1]], dp[i - 1][j]);
            }
            else
            {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    int res = dp[n][w];
    for (int i = n; i > 0 && res > 0; i--)
    {
        if (res == dp[i - 1][w])
            continue;
        else
        {
            v1.push_back(i - 1);
            res = res - price[i - 1];
            w = w - wgt[i - 1];
        }
    }
    cout << "Value = " << dp[n][w] << endl;
    cout << "Weights selected : ";
    for (int i = 0; i < v1.size(); i++)
    {
        cout << wgt[v1[i]] << " ";
    }
    cout << endl
         << "Weights selected : ";
    for (int i = 0; i < v1.size(); i++)
    {
        cout << price[v1[i]] << " ";
    }
    return 0;
    }

    OUTPUT

    Q3 : Given a string of characters, design an algorithm and implement it using a program to print all possible permutations of the string in lexicographic order.
#include <iostream> #include<bits/stdc++.h> using namespace std;
                                       void
                                       solve(string &str, vector<string> &res, int freq[], string &s, int n)
    {
        if (s.size() == n)
        {
            res.push_back(s);
            return;
        }
        for (int i = 0; i < n; i++)
        {
            if (freq[i] == 0)
            {
                s += str[i];
                freq[i] = 1;
                solve(str, res, freq, s, n);
                freq[i] = 0;
                s.pop_back();
            }
        }
    }
    int main()
    {
        string str;
        cin >> str;
        vector<string> res;
        string s = "";
        int n = str.size();
        int freq[n];
        memset(freq, 0, sizeof(freq));
        solve(str, res, freq, s, n);
        sort(res.begin(), res.end());
        for (int i = 0; i < res.size(); i++)
        {
            cout << res[i] << endl;
        }
        return 0;
    }
    OUTPUT

    WEEK 13 Q1 : Given an array of characters, you have to find distinct characters from this array.Design an algorithm and implement it using a program to solve this problem using hashing.(Time Complexity = O(n))
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n;      cin>>n;     char arr[n];     for(int i=0;i<n;i++)
    {
        cin >> arr[i];
    }
    map<char, int> mp;
    for (int i = 0; i < n; i++)
    {
        mp[arr[i]]++;
    }
    for (auto i : mp)
    {
        cout << i.first << " " << i.second << endl;
    }
    return 0;
    }

    OUTPUT

    Q2 : Given an array of integers of size n, design an algorithm and write a program to check whether this array contains duplicate within a small window of size k < n.
#include <iostream> #include<bits/stdc++.h> using namespace std;
                                                                                                                                                                        bool
                                                                                                                                                                        solve(int arr[], int n, int k)
    {
        unordered_set<int> s;
        for (int i = 0; i < n; i++)
        {
            if (s.find(arr[i]) != s.end())
                return true;
            s.insert(arr[i]);
            if (i >= k)
                s.erase(arr[i - k]);
        }
        return false;
    }
    int main()
    {
        int n, k, t;
        cin >> t;
        for (int c = 0; c < t; c++)
        {
            cin >> n;
            int arr[n];
            for (int i = 0; i < n; i++)
            {
                cin >> arr[i];
            }
            cin >> k;
            if (solve(arr, n, k))
            {
                cout << "Duplicate present in window " << k << endl;
            }
            else
            {
                cout << "Duplicate not present in window " << k << endl;
            }
        }
        return 0;
    }
    OUTPUT

    Q3 : Given an array of nonnegative integers, Design an algorithm and implement it using a program to find two pairs(a, b) and (c, d) such that a *b = c * d, where a, b, c and d are distinct elements of array.
#include <iostream>
#include <bits/stdc++.h> using namespace std;  void solve(int arr[],int n)
    {
        map<int, pair<int, int>> mp;
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                int prod = arr[i] * arr[j];
                if (mp.find(prod) == mp.end())
                    mp[prod] = make_pair(I, j);
                else
                {
                    pair<int, int> p = mp[prod];
                    cout << arr[p.first] <<” “<< arr[p.second] << endl;
                    cout << arr[i] <<” “<< arr[j] << endl;
                    return;
                }
            }
        }
    }
    int main()
    {
        int n;
        cin >> n;
        int arr[n];
        for (int i = 0; i < n; i++)
        {
            cin >> arr[i];
        }
        solve(arr, n);

        return 0;
    }
    OUTPUT

    WEEK 14 Q1 : Given a number n, write an algorithm and a program to find nth ugly number.Ugly numbers are those numbers whose only prime factors are 2, 3 or 5. The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, .is sequence of ugly numbers.
#include <iostream> #include<bits/stdc++.h> using namespace std; int main() {     int n,t;     cin>>t;
                                                                                                                                                                                                                                    for (int c = 0; c < t; c++)
    {
        cin >> n;
        int ugly[n];
        ugly[0] = 1;
        int num2 = 2, num3 = 3, num5 = 5, next_ugly = 1, i2 = 0, i3 = 0, i5 = 0;
        for (int i = 1; i < n; i++)
        {
            next_ugly = min(num2, min(num3, num5));
            ugly[i] = next_ugly;
            if (next_ugly == num2)
            {
                i2 += 1;
                num2 = ugly[i2] * 2;
            }
            if (next_ugly == num3)
            {
                i3 += 1;
                num3 = ugly[i3] * 3;
            }
            if (next_ugly == num5)
            {
                i5 += 1;
                num5 = ugly[i5] * 5;
            }
        }
        cout << next_ugly << endl;
    }
    return 0;
    }

    OUTPUT

    Q2 : Given a directed graph, write an algorithm and a program to find mother vertex in a graph.A mother vertex is a vertex v such that there exists a path from v to all other vertices of the graph.

#include <bits/stdc++.h>
                                 using namespace std;
    class Graph
    {
        int V;
        list<int> *adj;

        void DFSUtil(int v, vector<bool> &visited);

    public:
        Graph(int V);
        void addEdge(int v, int w);
        int findMother();
    };

    Graph::Graph(int V)
    {
        this->V = V;
        adj = new list<int>[V];
    }
    void Graph::DFSUtil(int v, vector<bool> &visited)
    {
        visited[v] = true;
        list<int>::iterator i;
        for (i = adj[v].begin(); i != adj[v].end(); ++i)
            if (!visited[*i])
                DFSUtil(*i, visited);
    }
    void Graph::addEdge(int v, int w)
    {
        adj[v].push_back(w);
    }
    int Graph::findMother()
    {
        vector<bool> visited(V, false);

        int v = 0;

        for (int i = 0; i < V; i++)
        {
            if (visited[i] == false)
            {
                DFSUtil(i, visited);
                v = i;
            }
        }
        fill(visited.begin(), visited.end(), false);
        DFSUtil(v, visited);
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                return -1;

        return v;
    }
    int main()
    {
        Graph g(6);
        g.addEdge(0, 3);
        g.addEdge(0, 4);
        g.addEdge(3, 1);
        g.addEdge(1, 5);
        g.addEdge(4, 2);
        g.addEdge(4, 5);
        cout << "A mother vertex is " << g.findMother();

        return 0;
    }

    OUTPUT
